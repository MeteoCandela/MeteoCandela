<!doctype html>
<html lang="ca">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>PrevisiÃ³ Ciutat de Valls Â· MeteoValls</title>
  <meta name="description" content="PrevisiÃ³ meteorolÃ²gica per Valls (Alt Camp): horÃ ria (properes 24 h) i previsiÃ³ diÃ ria 7 dies (AEMET).">

  <link rel="canonical" href="https://meteocandela.cat/previsio.html">
  <meta name="robots" content="index,follow">
  <meta name="theme-color" content="#0b1220">

  <meta property="og:type" content="article">
  <meta property="og:site_name" content="MeteoValls">
  <meta property="og:locale" content="ca_ES">
  <meta property="og:title" content="PrevisiÃ³ Â· MeteoValls (Valls Â· Alt Camp)">
  <meta property="og:description" content="PrevisiÃ³ horÃ ria (properes 24 h) i previsiÃ³ diÃ ria 7 dies (AEMET).">
  <meta property="og:url" content="https://meteocandela.cat/previsio.html">
  <meta property="og:image" content="https://meteocandela.cat/og-image.png">

  <link rel="stylesheet" href="style.css?v=2026-02-07-03">
</head>

<body>

  <header class="hero hero--small">
    <div class="hero__overlay"></div>
    <div class="hero__content">
      <h1>PrevisiÃ³ Ciutat de Valls</h1>
      <p>MeteoValls Â· Temps Vallenc</p>
      <div class="status" id="fxStatus">Carregant previsiÃ³â€¦</div>
    </div>
  </header>

  <main class="grid">

    <section class="card span2">
      <nav class="quick-nav" aria-label="NavegaciÃ³ principal">
        <a href="/index.html" class="quick-nav__btn">ğŸ  Inici</a>
        <a href="/historic.html" class="quick-nav__btn">ğŸ“Š HistÃ²ric</a>
      </nav>
    </section>

    <!-- HOURLY -->
    <section class="card span2">
      <h2>PrevisiÃ³ horÃ ria (properes 24 h)</h2>
      <div id="hourlyWrap">
        <p class="muted-line">Carregantâ€¦</p>
      </div>
    </section>

    <!-- DAILY -->
    <section class="card span2">
      <h2>PrevisiÃ³ 7 dies</h2>
      <div id="dailyWrap">
        <p class="muted-line">Carregantâ€¦</p>
      </div>
      <p class="muted-line" style="margin-top:12px">
        Nota: previsiÃ³ automÃ tica (pot variar).
      </p>
    </section>

    <!-- RESUM -->
    <section class="card span2">
      <h2>ObtenciÃ³ dades</h2>
      <div class="subs" id="fxMeta">
        <div>Font: â€”</div>
        <div>Actualitzat: â€”</div>
      </div>
    </section>

    <section class="card span2" style="text-align:center">
      <p><a href="/" class="back-link">â† Tornar a Inici</a></p>
    </section>

  </main>

  <footer class="footer">
    <span>Â© <span id="year"></span> MeteoValls</span>
  </footer>

  <script>
    // ===== Bootstrap =====
    document.getElementById("year").textContent = new Date().getFullYear();

    const API_BASE = "/api";
    const FORECAST_URL = `${API_BASE}/forecast`;
    const $ = (id) => document.getElementById(id);

    // ===== Helpers =====
    function hourNum(hourStr){
      const m = String(hourStr ?? "").match(/^\s*(\d{1,2})/);
      return m ? Number(m[1]) : NaN;
    }

    function fmt1(x){
      if (x === null || x === undefined) return "â€”";
      const s = String(x).trim();
      if (s === "") return "â€”";
      const n = Number(s);
      return Number.isFinite(n) ? n.toFixed(1) : "â€”";
    }

    function fmtInt(x){
      if (x === null || x === undefined) return "â€”";
      const s = String(x).trim();
      if (s === "") return "â€”";
      const n = Number(s);
      return Number.isFinite(n) ? String(Math.round(n)) : "â€”";
    }

    function fmt0orDash(x){
      if (x === null || x === undefined) return "â€”";
      const s = String(x).trim();
      if (s === "") return "â€”";
      const n = Number(s);
      return Number.isFinite(n) ? String(Math.round(n)) : "â€”";
    }

    function fmtDateCA(ymd){
      try{
        const [y,m,d] = String(ymd).slice(0,10).split("-").map(Number);
        const dt = new Date(y, m-1, d);
        return new Intl.DateTimeFormat("ca-ES", {
          weekday:"short",
          day:"2-digit",
          month:"2-digit"
        }).format(dt);
      }catch{
        return String(ymd || "â€”");
      }
    }

    function timeAgo(ts){
      const n = Number(ts);
      if (!Number.isFinite(n)) return "â€”";
      const mins = Math.round((Date.now() - n) / 60000);
      if (mins < 1) return "fa <1 min";
      if (mins < 60) return `fa ${mins} min`;
      const h = Math.round(mins / 60);
      return `fa ${h} h`;
    }

    function parseHourMin(hourStr){
      const m = String(hourStr ?? "").match(/^\s*(\d{1,2})(?::(\d{2}))?/);
      if (!m) return { h: NaN, min: 0 };
      return { h: Number(m[1]), min: m[2] ? Number(m[2]) : 0 };
    }

    function ymdTodayLocal(){
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${day}`;
    }

    function parseLocalDateTime(ymd, hourStr){
      const s = String(ymd || "").slice(0,10);
      const [Y,M,D] = s.split("-").map(Number);
      if (!Number.isFinite(Y) || !Number.isFinite(M) || !Number.isFinite(D)) return null;

      const { h, min } = parseHourMin(hourStr);
      if (!Number.isFinite(h)) return null;

      return new Date(Y, M-1, D, h, Number.isFinite(min) ? min : 0, 0, 0);
    }

    // Converteix una fila horÃ ria a Date (prioritat: ts_local > ts > date+hour > avui+hour)
    function rowToDate(row, todayYMD){
      // 1) ts_local ("YYYY-MM-DDTHH:00:00") -> parse LOCAL explÃ­cit
      const s = String(row?.ts_local ?? "").trim();
      if (s) {
        const m = s.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})(?::(\d{2}))?/);
        if (m) {
          const Y  = Number(m[1]);
          const Mo = Number(m[2]);
          const D  = Number(m[3]);
          const H  = Number(m[4]);
          const Mi = Number(m[5]);
          const S  = Number(m[6] ?? 0);
          const d = new Date(Y, Mo - 1, D, H, Mi, S, 0); // LOCAL
          if (!isNaN(d.getTime())) return d;
        }
      }

      // 2) ts (epoch ms)
      const ts = Number(row?.ts);
      if (Number.isFinite(ts)) {
        const d = new Date(ts);
        if (!isNaN(d.getTime())) return d;
      }

      // 3) date+hour
      if (row?.date) {
        const d = parseLocalDateTime(row.date, row.hour);
        if (d && !isNaN(d.getTime())) return d;
      }

      // 4) fallback: avui + hour
      const d = parseLocalDateTime(todayYMD, row?.hour);
      if (d && !isNaN(d.getTime())) return d;

      return null;
    }

    // Etiqueta horÃ ria (sempre des d'un Date)
    function fmtHourLabelFromDate(dt){
      try{
        return new Intl.DateTimeFormat("ca-ES", {
          weekday: "short",
          hour: "2-digit",
          minute: "2-digit"
        }).format(dt);
      }catch{
        return `${String(dt.getHours()).padStart(2,"0")}:00`;
      }
    }

    // TraducciÃ³ AEMET ES -> CA (robusta)
    function skyToCA(s){
      if (!s) return s;

      let t = String(s).trim().toLowerCase();

      // Connector castellÃ  -> catalÃ 
      t = t.replaceAll(" con ", " amb ");

      // FenÃ²mens
      t = t.replaceAll("lluvia escasa", "pluja feble");
      t = t.replaceAll("lluvia", "pluja");
      t = t.replaceAll("tormentas", "tempestes");
      t = t.replaceAll("tormenta", "tempesta");
      t = t.replaceAll("nieve", "neu");
      t = t.replaceAll("niebla", "boira");
      t = t.replaceAll("bruma", "broma");

      // Estat del cel
      t = t.replaceAll("intervalos nubosos", "intervals ennuvolats");
      t = t.replaceAll("poco nuboso", "poc ennuvolat");
      t = t.replaceAll("muy nuboso", "molt ennuvolat");
      t = t.replaceAll("nuboso", "ennuvolat");
      t = t.replaceAll("cubierto", "cobert");
      t = t.replaceAll("despejado", "serÃ¨");

      return t.charAt(0).toUpperCase() + t.slice(1);
    }

    // Icones en emoji (nit/dia + fenÃ²mens)
    function iconFromSky(s, hourStr){
      const h = hourNum(hourStr);
      const isNight = Number.isFinite(h) ? (h >= 20 || h < 8) : false;

      const t = String(s || "").toLowerCase();

      if (t.includes("torment")) return "â›ˆï¸";
      if (t.includes("nieve") || t.includes("neu")) return "ğŸŒ¨ï¸";
      if (t.includes("niebla") || t.includes("boira") || t.includes("bruma") || t.includes("broma")) return "ğŸŒ«ï¸";
      if (t.includes("pluja feble") || t.includes("lluvia escasa")) return "ğŸŒ¦ï¸";
      if (t.includes("pluja") || t.includes("lluvia")) return "ğŸŒ§ï¸";
      if (t.includes("cobert") || t.includes("cubierto")) return "â˜ï¸";
      if (t.includes("intervals") || t.includes("intervalos")) return isNight ? "â˜ï¸ğŸŒ™" : "ğŸŒ¤ï¸";
      if (t.includes("ennuvolat") || t.includes("nuboso")) return "â›…";
      if (t.includes("serÃ¨") || t.includes("despejado")) return isNight ? "ğŸŒ™" : "â˜€ï¸";

      return isNight ? "ğŸŒ™" : "ğŸŒ¤ï¸";
    }

    function fmtWind(h){
      const v = Number(h.wind_kmh);
      const g = Number(h.gust_kmh);
      const dir = h.wind_dir ? String(h.wind_dir) : "";

      const vTxt = Number.isFinite(v) ? `${Math.round(v)} km/h` : "â€”";
      const dTxt = dir ? ` ${dir}` : "";
      const gust = Number.isFinite(g) ? `<div class="fx-gust">ratxa ${Math.round(g)} km/h</div>` : "";

      return `
        <div class="fx-wind-main">${vTxt}${dTxt}</div>
        ${gust}
      `;
    }

    async function fetchForecast(){
      const res = await fetch(`${FORECAST_URL}?t=${Date.now()}`, { cache: "no-store" });
      const txt = await res.text();
      if (!res.ok) throw new Error(`${res.status} ${res.statusText}: ${txt.slice(0,140)}`);
      return JSON.parse(txt);
    }

    // ===== Renderers =====
    function renderHourly(hourly){
      const wrap = $("hourlyWrap");
      if (!wrap) return;

      if (!Array.isArray(hourly) || !hourly.length){
        wrap.innerHTML = `<p class="muted-line">Sense dades horÃ ries disponibles.</p>`;
        return;
      }

      // Properes 24 h des de l'hora actual arrodonida cap avall
      const now = new Date();
      const start = new Date(now);
      start.setMinutes(0,0,0);
      const startMs = start.getTime();
      const endMs = startMs + 24 * 60 * 60 * 1000;

      const todayYMD = ymdTodayLocal();

      // Parse + window filter
      let list = hourly
        .map(h => {
          const dt = rowToDate(h, todayYMD);
          const ms = dt ? dt.getTime() : NaN;
          return { ...h, _dt: dt, _ms: ms };
        })
        .filter(h => Number.isFinite(h._ms))
        .filter(h => h._ms >= startMs && h._ms < endMs)
        .sort((a,b) => a._ms - b._ms);

      // Dedup per hora (bucket)
      const seen = new Set();
      list = list.filter(h => {
        const bucket = Math.floor(h._ms / 3600000);
        if (seen.has(bucket)) return false;
        seen.add(bucket);
        return true;
      });

      if (!list.length){
        wrap.innerHTML = `<p class="muted-line">Sense dades per a les properes 24 h.</p>`;
        return;
      }

      wrap.innerHTML = `
        <div class="fx-shelf">
          <div class="fx-track" aria-hidden="true"></div>
          <div class="fx-rail" role="list" aria-label="PrevisiÃ³ properes 24 hores">
            ${list.map(h => {
              const dt = h._dt;
              const hourStrForIcon = dt
                ? `${String(dt.getHours()).padStart(2,"0")}:00`
                : (h.hour || "12:00");

              const skyCA = skyToCA(h.sky);

              return `
                <article class="fx-item" role="listitem">
                  <div class="fx-time">${dt ? fmtHourLabelFromDate(dt) : (h.hour || "â€”")}</div>
                  <div class="fx-icon" aria-hidden="true">${iconFromSky(skyCA, hourStrForIcon)}</div>
                  <div class="fx-temp">${fmt1(h.temp_c)}Â°</div>

                  <div class="fx-row">
                    <span class="fx-k">ğŸ’§</span>
                    <span class="fx-v">${fmt0orDash(h.pop_pct)}%</span>
                  </div>

                  <div class="fx-row fx-row--wind">
                    <span class="fx-k">ğŸ’¨</span>
                    <div class="fx-v">${fmtWind(h)}</div>
                  </div>
                </article>
              `;
            }).join("")}
          </div>
        </div>
      `;
    }

    function renderDaily(daily){
      const wrap = $("dailyWrap");
      if (!wrap) return;

      if (!Array.isArray(daily) || !daily.length){
        wrap.innerHTML = `<p class="muted-line">Sense dades diÃ ries disponibles.</p>`;
        return;
      }

      const mins = daily.map(d => Number(d.tmin_c)).filter(Number.isFinite);
      const maxs = daily.map(d => Number(d.tmax_c)).filter(Number.isFinite);
      const gMin = mins.length ? Math.min(...mins) : 0;
      const gMax = maxs.length ? Math.max(...maxs) : 0;
      const span = (gMax - gMin) || 1;

      const bar = (tmin, tmax) => {
        const a = Number(tmin), b = Number(tmax);
        if (!Number.isFinite(a) || !Number.isFinite(b)) return "";
        const left = ((a - gMin) / span) * 100;
        const width = ((b - a) / span) * 100;
        return `<div class="fx7-bar"><span style="left:${left}%;width:${width}%"></span></div>`;
      };

      wrap.innerHTML = `
        <div class="fx7">
          ${daily.map(d => {
            const skyCA = skyToCA(d.sky);
            return `
              <div class="fx7-row">
                <div class="fx7-left">
                  <div class="fx7-date">${fmtDateCA(d.date)}</div>
                  <div class="fx7-sky">${skyCA || ""}</div>
                </div>

                <div class="fx7-mid">
                  <div class="fx7-icon" aria-hidden="true">${iconFromSky(skyCA, "12:00")}</div>
                  ${bar(d.tmin_c, d.tmax_c)}
                </div>

                <div class="fx7-right">
                  <div class="fx7-temps">
                    <span class="fx7-min">${fmt1(d.tmin_c)}Â°</span>
                    <span class="fx7-max">${fmt1(d.tmax_c)}Â°</span>
                  </div>
                  <div class="fx7-pop">ğŸ’§ ${fmtInt(d.pop_pct)}%</div>
                </div>
              </div>
            `;
          }).join("")}
        </div>
      `;
    }

    // ===== Main =====
    async function main(){
      const status = $("fxStatus");
      const meta = $("fxMeta");

      try{
        const fx = await fetchForecast();

        const provider = fx.provider || "â€”";
        const place = fx.place || "Valls (Alt Camp)";
        const updated = fx.updated_ts ? timeAgo(fx.updated_ts) : "â€”";

        if (status) status.textContent = `PrevisiÃ³: ${place} Â· ${provider} Â· Actualitzat ${updated}.`;
        if (meta) {
          meta.innerHTML = `
            <div>Font: <strong>${provider}</strong></div>
            <div>Actualitzat: <strong>${fx.updated_iso_utc ? fx.updated_iso_utc.replace("T"," ").slice(0,16) : "â€”"}</strong> (${updated})</div>
          `;
        }

        renderHourly(fx.hourly);
        renderDaily(fx.daily);

      } catch(e){
        console.error(e);
        if (status) status.textContent = "No es pot carregar la previsiÃ³ (/api/forecast).";
        const hw = $("hourlyWrap"); if (hw) hw.innerHTML = `<p class="muted-line">Error carregant previsiÃ³.</p>`;
        const dw = $("dailyWrap");  if (dw) dw.innerHTML = `<p class="muted-line">Error carregant previsiÃ³.</p>`;
      }
    }

    main();
  </script>

</body>
</html>
