name: Ecowitt updater

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"

concurrency:
  group: ecowitt-updater
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  update:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Fetch Ecowitt current + history(5min)
        env:
          ECOWITT_APPLICATION_KEY: ${{ secrets.ECOWITT_APPLICATION_KEY }}
          ECOWITT_API_KEY: ${{ secrets.ECOWITT_API_KEY }}
          ECOWITT_MAC: ${{ secrets.ECOWITT_MAC }}
          # Posa-ho a "1" temporalment si vols veure el payload de pluja a logs
          ECOWITT_DEBUG: "0"
        run: |
          python - <<'PY'
          import json, os, time, socket
          from datetime import datetime, timezone
          from pathlib import Path
          import urllib.request, urllib.parse

          # ====== Config ======
          DATA_DIR = Path("data")
          HISTORY_PATH = DATA_DIR / "history.json"
          CURRENT_PATH = DATA_DIR / "current.json"

          HEARTBEAT_DIR = Path("heartbeat")
          HEARTBEAT_PATH = HEARTBEAT_DIR / "heartbeat.json"

          DAYS_TO_KEEP = 30
          OVERLAP_MS = 60 * 60 * 1000  # 60 min
          URL_TIMEOUT = 20
          RETRIES = 3
          BACKOFF_BASE = 2

          DEBUG = (os.getenv("ECOWITT_DEBUG", "0").strip() == "1")

          socket.setdefaulttimeout(URL_TIMEOUT)

          app_key = os.getenv("ECOWITT_APPLICATION_KEY")
          api_key = os.getenv("ECOWITT_API_KEY")
          mac = os.getenv("ECOWITT_MAC")
          if not (app_key and api_key and mac):
              raise SystemExit("Falten secrets: ECOWITT_APPLICATION_KEY / ECOWITT_API_KEY / ECOWITT_MAC")

          def ensure_dirs():
              DATA_DIR.mkdir(parents=True, exist_ok=True)
              HEARTBEAT_DIR.mkdir(parents=True, exist_ok=True)

          def write_json(path: Path, obj):
              path.write_text(json.dumps(obj, ensure_ascii=False), encoding="utf-8")

          def read_json(path: Path, default=None):
              if path.exists():
                  try:
                      return json.loads(path.read_text(encoding="utf-8"))
                  except Exception:
                      return default
              return default

          def read_hist():
              h = read_json(HISTORY_PATH, default=[])
              return h if isinstance(h, list) else []

          def write_heartbeat(now_ms, note=""):
              hb = {
                  "run_ts": now_ms,
                  "run_iso_utc": datetime.now(timezone.utc).isoformat(),
              }
              if note:
                  hb["note"] = note
              write_json(HEARTBEAT_PATH, hb)
              return hb

          # ====== numeric helpers ======
          def fnum(x):
              try:
                  return float(x)
              except Exception:
                  return None

          def f_to_c(v):
              try:
                  return (float(v) - 32.0) * 5.0 / 9.0
              except Exception:
                  return None

          def mph_to_kmh(v):
              try:
                  return float(v) * 1.609344
              except Exception:
                  return None

          def ms_to_kmh(v):
              try:
                  return float(v) * 3.6
              except Exception:
                  return None

          def inch_to_mm(v):
              try:
                  return float(v) * 25.4
              except Exception:
                  return None

          def cm_to_mm(v):
              try:
                  return float(v) * 10.0
              except Exception:
                  return None

          def norm_rain(v, unit):
              """Retorna pluja en mm (o mm/h) a partir d'unitats Ecowitt."""
              v = fnum(v)
              if v is None:
                  return None
              u = (str(unit).strip().lower() if unit else "")
              # típics: "in", "in/hr", "mm", "mm/h", "cm"
              if "in" in u:
                  return inch_to_mm(v)
              if "cm" in u:
                  return cm_to_mm(v)
              return float(v)

          def to_ms_epoch(s):
              if s is None:
                  return None
              try:
                  x = float(s)
                  if x > 1e12:  # ms
                      return int(x)
                  if x > 1e9:   # s
                      return int(x * 1000)
              except Exception:
                  pass
              return None

          def is_fahrenheit(unit):
              """Heurística Ecowitt: si unit és 'F' -> F; si 'C' -> C; si falta, sovint ve en F."""
              if unit:
                  u = str(unit).strip().lower()
                  if u.startswith("f"):
                      return True
                  if u.startswith("c"):
                      return False
              return True

          # ====== HTTP robust ======
          def fetch_url_json(url):
              last_err = None
              for i in range(RETRIES):
                  try:
                      with urllib.request.urlopen(url, timeout=URL_TIMEOUT) as r:
                          return json.loads(r.read().decode("utf-8"))
                  except Exception as e:
                      last_err = e
                      sleep_s = (BACKOFF_BASE ** i)
                      print(f"[WARN] fetch fail ({i+1}/{RETRIES}) -> {type(e).__name__}: {e}. retry in {sleep_s}s")
                      time.sleep(sleep_s)
              raise last_err

          # ====== extraction helpers ======
          def deep_get(d, *keys):
              cur = d
              for k in keys:
                  if not isinstance(cur, dict) or k not in cur:
                      return None
                  cur = cur[k]
              return cur

          def val_unit(x):
              """Accepta dicts tipus {value, unit} o valors simples."""
              if isinstance(x, dict):
                  return x.get("value"), (x.get("unit") or x.get("units"))
              return x, None

          # =========================
          #  A) CURRENT (real_time)
          # =========================
          def fetch_realtime_row(now_ms):
              base_url = "https://api.ecowitt.net/api/v3/device/real_time"
              params = {
                  "application_key": app_key,
                  "api_key": api_key,
                  "mac": mac,
                  "call_back": "all",
              }
              url = base_url + "?" + urllib.parse.urlencode(params)
              payload = fetch_url_json(url)
              data = payload.get("data", {}) if isinstance(payload, dict) else {}

              if DEBUG:
                  rain_keys = [k for k in (data.keys() if isinstance(data, dict) else []) if "rain" in k.lower()]
                  print("[DEBUG] rain keys:", rain_keys)
                  print("[DEBUG] rainfall:", data.get("rainfall") if isinstance(data, dict) else None)
                  print("[DEBUG] rainfall_piezo:", data.get("rainfall_piezo") if isinstance(data, dict) else None)

              # temperatura / humitat / rosada
              t_v, t_u = val_unit(deep_get(data, "outdoor", "temperature") or data.get("temperature") or data.get("temp"))
              h_v, _   = val_unit(deep_get(data, "outdoor", "humidity") or data.get("humidity"))
              d_v, d_u = val_unit(deep_get(data, "outdoor", "dew_point") or data.get("dew_point"))

              t_raw = fnum(t_v)
              h_raw = fnum(h_v)
              d_raw = fnum(d_v)

              temp_c = f_to_c(t_raw) if (t_raw is not None and is_fahrenheit(t_u)) else t_raw
              dew_c  = f_to_c(d_raw) if (d_raw is not None and is_fahrenheit(d_u)) else d_raw

              # vent / ratxa
              ws_v, ws_u = val_unit(data.get("wind_speed") or deep_get(data, "wind", "wind_speed"))
              gs_v, gs_u = val_unit(data.get("wind_gust")  or deep_get(data, "wind", "wind_gust"))

              def norm_w(v, unit):
                  v = fnum(v)
                  if v is None:
                      return None
                  u = (str(unit).lower() if unit else "")
                  if "mph" in u:
                      return mph_to_kmh(v)
                  if u in ("m/s", "ms", "mps"):
                      return ms_to_kmh(v)
                  return float(v)

              wind_kmh = norm_w(ws_v, ws_u)
              gust_kmh = norm_w(gs_v, gs_u)

              wind_dir = (
                  deep_get(data, "wind_direction", "value")
                  or data.get("wind_direction")
                  or deep_get(data, "wind", "wind_direction", "value")
                  or deep_get(data, "wind", "wind_direction")
              )
              wind_dir = str(wind_dir) if wind_dir is not None else None

              # ---- PLUJA ----
              # IMPORTANT:
              #  - En WS85: data["rainfall_piezo"]["daily"] unit 'in'
              #  - En WS85: data["rainfall_piezo"]["rain_rate"] unit 'in/hr'
              rd_v, rd_u = val_unit(
                  deep_get(data, "rainfall_piezo", "daily")
                  or deep_get(data, "rainfall", "daily")
                  or data.get("rainfall_daily")
                  or data.get("rain_day")
                  or data.get("daily_rain")
              )

              rr_v, rr_u = val_unit(
                  deep_get(data, "rainfall_piezo", "rain_rate")   # ✅ clau bona WS85
                  or deep_get(data, "rainfall", "rain_rate")
                  or data.get("rain_rate")
                  or deep_get(data, "rainfall_piezo", "rate")      # fallback antic
                  or deep_get(data, "rainfall", "rate")
              )

              rain_day  = norm_rain(rd_v, rd_u)
              rain_rate = norm_rain(rr_v, rr_u)

              # si no ve intensitat, NO fem fallback: posem 0.0 per no quedar enganxat
              if rain_rate is None:
                  rain_rate = 0.0

              return {
                  "ts": now_ms,
                  "temp_c": None if temp_c is None else float(temp_c),
                  "hum_pct": None if h_raw  is None else float(h_raw),
                  "dew_c":  None if dew_c  is None else float(dew_c),
                  "wind_kmh": None if wind_kmh is None else float(wind_kmh),
                  "gust_kmh": None if gust_kmh is None else float(gust_kmh),
                  "wind_dir": wind_dir,
                  "rain_day_mm": None if rain_day is None else float(rain_day),
                  "rain_rate_mmh": float(rain_rate),
              }

          # =========================
          #  B) HISTORY (5min)
          # =========================
          def fetch_history_rows(start_s, end_s):
              base_url = "https://api.ecowitt.net/api/v3/device/history"
              params = {
                  "application_key": app_key,
                  "api_key": api_key,
                  "mac": mac,
                  "cycle_type": "5min",
                  "call_back": "all",
                  "start_time": int(start_s),
                  "end_time": int(end_s),
              }
              url = base_url + "?" + urllib.parse.urlencode(params)
              payload = fetch_url_json(url)
              if not isinstance(payload, dict):
                  raise RuntimeError(f"Resposta inesperada history: {type(payload)}")

              data = payload.get("data") or payload.get("datas") or payload.get("result") or payload.get("records")
              if data is None:
                  return []

              if isinstance(data, dict):
                  data_list = data.get("list") or data.get("data") or data.get("records")
              elif isinstance(data, list):
                  data_list = data
              else:
                  data_list = None

              if not isinstance(data_list, list):
                  return []

              def parse_row(r):
                  if not isinstance(r, dict):
                      return None

                  ts_ms = (
                      to_ms_epoch(r.get("ts"))
                      or to_ms_epoch(r.get("time"))
                      or to_ms_epoch(r.get("timestamp"))
                      or to_ms_epoch(r.get("dateutc"))
                  )
                  if ts_ms is None and isinstance(r.get("time"), str):
                      try:
                          dt = datetime.strptime(r["time"], "%Y-%m-%d %H:%M").replace(tzinfo=timezone.utc)
                          ts_ms = int(dt.timestamp() * 1000)
                      except Exception:
                          return None
                  if ts_ms is None:
                      return None

                  t_v, t_u = val_unit(deep_get(r, "outdoor", "temperature") or r.get("temperature") or r.get("temp"))
                  h_v, _   = val_unit(deep_get(r, "outdoor", "humidity") or r.get("humidity"))
                  d_v, d_u = val_unit(deep_get(r, "outdoor", "dew_point") or r.get("dew_point"))

                  t_raw = fnum(t_v)
                  h_raw = fnum(h_v)
                  d_raw = fnum(d_v)

                  temp_c = f_to_c(t_raw) if (t_raw is not None and is_fahrenheit(t_u)) else t_raw
                  dew_c  = f_to_c(d_raw) if (d_raw is not None and is_fahrenheit(d_u)) else d_raw

                  ws_v, ws_u = val_unit(r.get("wind_speed") or deep_get(r, "wind", "wind_speed"))
                  gs_v, gs_u = val_unit(r.get("wind_gust")  or deep_get(r, "wind", "wind_gust"))

                  def norm_w(v, unit):
                      v = fnum(v)
                      if v is None:
                          return None
                      u = (str(unit).lower() if unit else "")
                      if "mph" in u:
                          return mph_to_kmh(v)
                      if u in ("m/s", "ms", "mps"):
                          return ms_to_kmh(v)
                      return float(v)

                  wind_kmh = norm_w(ws_v, ws_u)
                  gust_kmh = norm_w(gs_v, gs_u)

                  wind_dir = (r.get("wind_direction") or deep_get(r, "wind", "wind_direction"))
                  wind_dir = str(wind_dir) if wind_dir is not None else None

                  # pluja: history sovint no dona rain_rate; si falta -> 0.0 (no enganxar)
                  rd_v, rd_u = val_unit(
                      deep_get(r, "rainfall_piezo", "daily")
                      or deep_get(r, "rainfall", "daily")
                      or r.get("rainfall_daily")
                      or r.get("rain_day")
                      or r.get("daily_rain")
                  )

                  rr_v, rr_u = val_unit(
                      deep_get(r, "rainfall_piezo", "rain_rate")
                      or deep_get(r, "rainfall", "rain_rate")
                      or r.get("rain_rate")
                      or deep_get(r, "rainfall_piezo", "rate")
                      or deep_get(r, "rainfall", "rate")
                  )

                  rain_day  = norm_rain(rd_v, rd_u)
                  rain_rate = norm_rain(rr_v, rr_u)
                  if rain_rate is None:
                      rain_rate = 0.0

                  return {
                      "ts": int(ts_ms),
                      "temp_c": None if temp_c is None else float(temp_c),
                      "hum_pct": None if h_raw  is None else float(h_raw),
                      "dew_c":  None if dew_c  is None else float(dew_c),
                      "wind_kmh": None if wind_kmh is None else float(wind_kmh),
                      "gust_kmh": None if gust_kmh is None else float(gust_kmh),
                      "wind_dir": wind_dir,
                      "rain_day_mm": None if rain_day is None else float(rain_day),
                      "rain_rate_mmh": float(rain_rate),
                  }

              out = []
              for r in data_list:
                  row = parse_row(r)
                  if row:
                      out.append(row)
              return out

          # ============= RUN =============
          ensure_dirs()
          now_ms = int(time.time() * 1000)
          cutoff_ms = now_ms - DAYS_TO_KEEP * 24 * 60 * 60 * 1000

          hist = read_hist()
          hist = [h for h in hist if isinstance(h, dict) and isinstance(h.get("ts"), (int, float))]
          hist.sort(key=lambda x: int(x["ts"]))
          last_ts_ms = int(hist[-1]["ts"]) if hist else None

          notes = []

          # A) CURRENT
          current_row = None
          try:
              current_row = fetch_realtime_row(now_ms)

              # fallback només per pluja diària (mateix dia UTC), MAI per rain_rate
              prev = read_json(CURRENT_PATH, default=None)
              if isinstance(prev, dict) and isinstance(current_row, dict) and "ts" in prev and "ts" in current_row:
                  try:
                      prev_day = datetime.fromtimestamp(int(prev["ts"])/1000, tz=timezone.utc).date()
                      cur_day  = datetime.fromtimestamp(int(current_row["ts"])/1000, tz=timezone.utc).date()
                  except Exception:
                      prev_day = cur_day = None

                  if prev_day == cur_day:
                      if current_row.get("rain_day_mm") is None and prev.get("rain_day_mm") is not None:
                          current_row["rain_day_mm"] = prev["rain_day_mm"]

              # assegurem intensitat sempre numèrica
              if current_row.get("rain_rate_mmh") is None:
                  current_row["rain_rate_mmh"] = 0.0

              write_json(CURRENT_PATH, current_row)

          except Exception as e:
              notes.append(f"realtime fail: {type(e).__name__}")
              prev = read_json(CURRENT_PATH, default=None)
              if isinstance(prev, dict) and isinstance(prev.get("ts"), (int, float)):
                  current_row = prev
              else:
                  current_row = None

          # B) HISTORY
          try:
              if last_ts_ms is None:
                  start_ms = cutoff_ms
              else:
                  start_ms = max(last_ts_ms - OVERLAP_MS, cutoff_ms)

              start_s = int(start_ms / 1000)
              end_s = int(now_ms / 1000)

              rows = fetch_history_rows(start_s, end_s)

              new_rows = []
              for r in rows:
                  if last_ts_ms is None or int(r["ts"]) > last_ts_ms:
                      new_rows.append(r)

              merged = hist + new_rows

              # també persistim el punt realtime
              if isinstance(current_row, dict) and isinstance(current_row.get("ts"), (int, float)):
                  merged.append(current_row)

              # dedupe per ts (últim guanya)
              by_ts = {}
              for r in merged:
                  ts = r.get("ts")
                  if isinstance(ts, (int, float)):
                      by_ts[int(ts)] = r

              merged = [by_ts[k] for k in sorted(by_ts.keys())]
              merged = [r for r in merged if int(r["ts"]) >= cutoff_ms]

              write_json(HISTORY_PATH, merged)

              if not new_rows:
                  notes.append("history: no new 5min row yet (normal delay)")

          except Exception as e:
              notes.append(f"history fail: {type(e).__name__}")

          hb = write_heartbeat(now_ms, note=" · ".join(notes))
          print("Heartbeat:", hb)
          print("History points:", len(read_hist()))
          PY

      - name: Commit & push (only if changed)
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "Update meteo data"
          file_pattern: |
            data/history.json
            data/current.json
            heartbeat/heartbeat.json
